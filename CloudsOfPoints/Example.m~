clear all;
close all;

% Fast computation of the vector q defined by 
% q_k = \sum_{l = 1}^{N_y} G(X_k - Y_l) f_l, k = 1 .. Nx


Nx = 10^4;
Ny = 10^4;
% Data points
X = uniformDisk([0,0],1,Nx);
Y = uniformDisk([0.2,0],1,Ny);
f = rand(size(Y,1),1); % Vector f

% Parameter for rescaling
rMax = rMaxCalc(X,Y);
% G = LogKernel()
% G = Y0Kernel(1);
% G = Y0Kernel(50);
G = ThinPlate(10,25);
% G = Kernel(@(r)(1./r.^2 ),@(r)(-2./r.^3));
% Choice of the cutoff parameter. 
lambda = 3;
a = lambda/sqrt(sqrt(Nx*Ny)); %this value is of the order of the optimal 
% value for data uniformly distributed in a disk. Choose lambda by trial
% and error to minimize the online time.
tol = 1e-4; % input tolerance

% Offline computations.

[onlineEBD,rq,loc] = offlineEBD(G,X,Y,a,tol); 
% show the radial quadrature : 
rq.show;


% Online procedure.
tic;
q = onlineEBD(f);
toc;

% Error on first entry of q 
dist = sqrt((X(1,1) - Y(:,1)).^2 + (X(1,2) - Y(:,2)).^2);
qval = sum(G.func(dist).*f);
disp('error on first entry');
disp(abs(qval - q(1))/(norm(q,1)));

% Error when f = [1 0 0 ... 0] (worst case). 
dist = sqrt((X(:,1) - Y(1,1)).^2 + (X(:,2) - Y(1,2)).^2);
f = [1; zeros(size(Y,1)-1,1)];
q = onlineEBD(f);
qval = G.func(dist);
disp('Linf error for f = [1 0 0 ... 0] (worst case) / target accuracy');
fprintf('%s / %s',max(abs(qval - q),tol))

